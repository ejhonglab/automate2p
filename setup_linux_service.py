#!/usr/bin/env python3

# DO NOT CALL THIS SCRIPT DIRECTLY!!! Call setup_linux_service.sh instead.

# This script and service template adapted from sumid's answer here:
# https://askubuntu.com/questions/25071

import getpass
import argparse
import os
from os.path import join, splitext, exists, islink, isfile, abspath, isdir
from subprocess import Popen, check_output, CalledProcessError
import time
import warnings
import traceback
from shutil import copyfile
import re
import pickle

import util


def get_drive_info():
    n_constant_lines_at_end = 7
    def get_systemctl_unit_lines():
        sc_unit_lines = check_output('systemctl list-units -t mount'.split())

        return [b' '.join(line.split()) for line in
            sc_unit_lines.splitlines()[
            :-n_constant_lines_at_end]
        ]

    input('If the drive of interest is connected, disconnect it now. '
        'Press any key afterward.'
    )
    time.sleep(0.5)
    lines_without_drive = get_systemctl_unit_lines()

    input('Now connect the drive, and press any key afterward.')
    max_retry_time_s = 10.0
    sleep_time_s = 3.0

    drive_line = None
    while True:
        lines_with_drive = get_systemctl_unit_lines()

        if len(lines_with_drive) == len(lines_without_drive):
            time.sleep(sleep_time_s)
            continue

        drive_line_set = set(lines_with_drive) - set(lines_without_drive)
        assert len(drive_line_set) == 1, f'actual len was {len(drive_line_set)}'
        drive_line = drive_line_set.pop()
        break

    if drive_line is None:
        raise ValueError('no new drive found before timeout')

    drive_line_parts = drive_line.decode('utf-8').split()
    drive_systemctl_unit = drive_line_parts[0]

    # So this path may now have (unescaped) spaces in it.
    # This is fine for Python calls, but may cause problems w/ shell calls.
    mount_point = ' '.join(drive_line_parts[4:])
    assert isdir(mount_point), f'mount point {mount_point} did not exist'

    return drive_systemctl_unit, mount_point


def get_drive_fstab_info(mount_point):
    """
    mount_point should NOT have spaces escaped

    Returns UUID and filesystem type.
    """
    with open('/proc/mounts', 'r') as f:
        mount_lines = f.read().splitlines()

    dev = None
    for line in mount_lines:
        # Spaces are escaped in /proc/mounts, so we can split on them and count
        # parts.
        line_dev, line_mount = line.split()[:2]
        line_mount = line_mount.replace('\\040',' ')
        if line_mount == mount_point:
            assert dev is None, 'only expected at most one matching mount line'
            dev = line_dev

    assert dev is not None
    dev_prefix = '/dev/'
    assert dev.startswith(dev_prefix)
    # second slash in prefix is kept, but that's useful for matching ls output
    dev = dev[-len(dev_prefix):]

    lines = check_output('ls -la /dev/disk/by-uuid'.split()).splitlines()[1:]
    uuid = None
    for line in lines:
        line = line.decode('utf-8')
        parts = line.split()
        if parts[-2] != '->':
            continue
        if parts[-1].endswith(dev):
            uuid = parts[-3]
    assert uuid is not None

    # Using this command to get filesystem type, as opposed to a few
    # alternatives, because this returns exfat rather than fuseblk for exfat.
    lines = check_output(['blkid']).splitlines()
    filesystem_type = None
    for line in lines:
        line = line.decode('utf-8')
        
        # Assuming we don't need to check for duplicate matches.
        match = re.search(r'\sUUID="([^"]+)"', line)
        if match is None:
            continue
        line_uuid = match.groups()[0]

        if line_uuid == uuid:
            assert filesystem_type is None, \
                'expected only one line matching UUID'

            parts = line.split()
            assert parts[0].endswith(':') and parts[0][:-1].endswith(dev)

            filesystem_type = re.search(r'\sTYPE="([^"]+)"', line).groups()[0]

            # TODO test fstab to see if this or other uuid is what i want
            # seems to work w/ other uuid in this case
            #part_uuid = re.search(r'\sPARTUUID="([^"]+)"', line).groups()[0]
            #print('part_uuid:', part_uuid)
            #

    assert filesystem_type is not None
    return uuid, filesystem_type


fstab_gen_indicator_line = ('# The following line was generated by '
    'automate2p/setup_linux_serice.py'
)
def uuid_in_fstab(uuid):
    fstab_lines = fstab_contents.splitlines()
    uuid_prefix = 'UUID='
    uuid_found = False
    line_num = None
    for i, line in enumerate(fstab_lines):
        if line.startswith(uuid_prefix):
            parts = line.split()
            if parts[0][len(uuid_prefix):] == uuid:
                assert line_num is None
                line_num = i
                uuid_found = True

    if not uuid_found:
        generated = None
    elif line_num == 0:
        generated = False
    else:
        generated = fstab_lines[line_num - 1] == fstab_gen_indicator_line

    return uuid_found, line_num, generated


def add_fstab_lines(uuid, mount_point, filesystem):
    """
    mount_point should NOT have spaces escaped
    """
    uuid_found, _, _ = uuid_in_fstab(uuid)
    if uuid_found:
        print('line with UUID already in fstab. not changing fstab.')
        return

    supported_filesystems = {
        'exfat',
    }
    if filesystem not in supported_filesystems:
        raise NotImplementedError('only currently supported filesystems are:\n'
            f'{supported_filesystems}'
        )

    if filesystem == 'exfat':
        warnings.warn('assuming appropriate exfat utils are already installed')

    # TODO could also lookup options, but not sure which/where are right
    # set w/ exfat, since fstype in /proc/mounts is wrong, are options too?
    # right options somewhere else? (blkid does not seem like it can output
    # these options)

    # This seems to be appropriate escaping for fstab.
    space_escaped_mount_point = r'\040'.join(mount_point.split())
    # TODO defaults OK? what are last two args again?
    # and what indicates drive should not be mounted automatically?
    # (don't want this hanging boot...)
    fstab_line = (f'UUID={uuid} {space_escaped_mount_point} {filesystem} '
        'defaults 0 1'
    )
    print('')
    print(fstab_line)
    # TODO make prompt robust
    choice = input('Add the above line to fstab? [y/n] ').lower()
    if choice == 'y':
        fstab_lines = fstab_contents.splitlines()
        n_old_fstab_lines = len(fstab_lines)

        with open('/etc/fstab', 'a') as f:
            # 3 lines. Same number removed below (hardcoded).
            # Not clear on why two newlines are required at beginning to make a 
            # total of three lines...
            f.write('\n\n' + fstab_gen_indicator_line + '\n' + fstab_line +
                '\n'
            )

        with open('/etc/fstab', 'r') as f:
            new_content = f.read()
        new_lines = new_content.splitlines()
        assert len(new_lines) == n_old_fstab_lines + 3, \
            f'only {len(new_lines) - n_old_fstab_lines} new lines'

        # TODO need to catch if it was already unmounted?
        print('unmounting drive')
        # TODO need to worry about / change args to avoid / deal w/
        # "WARN: volume was not unmounted cleanly" output?
        # (though it doesn't seem to show up here... maybe when service is
        # started?)
        Popen(f'umount /dev/disk/by-uuid/{uuid}'.split())

        # TODO need to catch this is drive is unconnected?
        print('remounting everything in modified fstab')
        Popen('mount -a'.split())

        # TODO test mount to make sure fstab line works (need to unmount drive
        # first prob) parse mount -a output? then check mount point has stuff
        # under it?


def remove_fstab_lines(uuid):
    uuid_found, line_num, generated = uuid_in_fstab(uuid)
    if not generated:
        print('not removing fstab lines because this script did not generate'
            ' them'
        )
        return

    assert line_num >= 2
    fstab_lines = fstab_contents.splitlines()
    lines_before = fstab_lines[:(line_num - 2)]
    lines_after = fstab_lines[(line_num + 1):]
    new_lines = lines_before + lines_after
    new_contents = '\n'.join(new_lines)

    assert (
        len(new_contents.splitlines()) == (len(fstab_contents.splitlines()) - 3)
    )

    with open('/etc/fstab', 'w') as f:
        print('overwriting fstab to remove generated lines')
        f.write(new_contents)


def systemctl_call(action, user=False):
    if action == 'stop':
        print('stopping service')
    elif not action.endswith('e'):
        print(f'{action}ing service')
    else:
        print(f'{action[:-1]}ing service')

    parts = ['systemctl', action]
    if user:
        # still don't really understand this...
        # (and is this flag + a User line an error?)
        parts.append('--user')

    parts.append(service_name)
    return check_output(parts)


def install(python_path=None):
    add_fstab_lines(uuid, mount_point, filesystem_type)

    abspath_script_to_trigger = abspath('linux_on_usb_connect.py')
    assert exists(abspath_script_to_trigger), \
        f'script to trigger did not exist at {abspath_script_to_trigger}'

    assert exists(example_config), f'no example config at {example_config}'
    if exists(service_config_file):
        # In case we double install, don't want to overwrite some config
        # that may have already been edited.
        print(f'leaving existing config file at {service_config_file}')
    else:
        print(f'copying example config to {service_config_file}')
        copyfile(example_config, service_config_file)
        Popen(['chown', f'{args.user}:{args.user}', service_config_file])

    # TODO delete mount point stuff if i can't figure out escaping / 
    # unless there's some other case where it's not derivable directly
    # from service unit
    with open(service_templ_path, 'r') as f:
        service = f.read().replace('{drive_systemctl_unit}',
            drive_systemctl_unit).replace('{mount_point}', mount_point
            ).replace('{abspath_script_to_trigger}', abspath_script_to_trigger
        )

    # From testing, escaping this but not Requires/After seemed
    # to work (i.e. actually get triggered when drive is connected).
    service = service.replace('{escaped_drive_systemctl_unit}',
        drive_systemctl_unit.replace('\\', '\\\\')
    )

    # TODO should just enforce required earlier if it *is* required...
    assert args.user
    print(f'will run triggered script as user {args.user}')
    service = service.replace('{nonroot_user}', args.user)

    if python_path is None:
        print('not using explicit python interpreter')
        # Note that this also includes the following space.
        service = service.replace('{abspath_python} ', '')
    else:
        print(f'using python interpreter at {python_path} to run triggered '
            'script'
        )
        assert exists(python_path), f'python at {python_path} did not exist'
        service = service.replace('{abspath_python}', python_path)

    if exists(service_path):
        warnings.warn(f'overwriting service already installed at '
            '{service_path}'
        )

    assert '{' not in service and '}' not in service, \
        'unhandled template variables seem to remain'

    with open(service_path, 'w') as f:
        print(f'writing service file to {service_path}')
        f.write(service)

    systemctl_call('enable')

    if args.test_start:
        try:
            systemctl_call('start')

        # This will happen if, for instance, the drive is not connected.
        except CalledProcessError as e:
            warnings.warn('could not start the just-installed service. '
                'is the drive connected?'
            )
    

def remove():
    remove_fstab_lines(uuid)

    if islink(service_path):
        raise IOError(f'{service_path} already existed as a symlink, which '
            'means this script did not install it.')

    # Calling stop / disable / etc first in case they want service file
    # to still be in place.
    try:
        systemctl_call('stop')
        service_stop_successful = True
    except CalledProcessError as e:
        service_stop_successful = False
        traceback_str = traceback.format_exc()
        # Not exiting yet, because if we installed some service files that
        # were invalid, and thus could not be installed, we still want to 
        # delete those.

    try:
        systemctl_call('disable')
        disable_success = True
    except CalledProcessError as e:
        disable_success = False
        print('\nDisabling service failed with:')
        print(traceback.format_exc())
        print('This may have been because the service was not installed.\n')

    if service_stop_successful or disable_success:
        # Also including these two lines as per:
        # https://superuser.com/questions/513159
        # (nothing similar needed on install, right?)
        print('systemctl daemon-reload')
        Popen(f'systemctl daemon-reload'.split())
        print('systemctl reset-failed')
        Popen(f'systemctl reset-failed'.split())

    if isfile(service_path):
        print(f'removing service installed at {service_path}')
        os.remove(service_path)
    else:
        print(f'no file at {service_path} to uninstall')

    if exists(service_config_file):
        print(f'removing config file at {service_config_file}')
        os.remove(service_config_file)

    if not service_stop_successful:
        print('')
        print(traceback_str)
        # Max # of incorrect sudo password attempts seems to yield
        # exit status 1, for example.
        if traceback_str.endswith('exit status 5.\n'):
            print('Service did not seem to be installed.')


if __name__ == '__main__':
    if getpass.getuser() != 'root':
        raise ValueError(
            'this script should be run by calling setup_linux_service.sh'
        )

    parser = argparse.ArgumentParser(description='Install/remove copy-on-USB '
        'connect systemctl service.'
    )
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('--install', action='store_true')
    group.add_argument('--remove', action='store_true')
    group.add_argument('--remove-last-installed', action='store_true')

    parser.add_argument('--test-start', action='store_true',
        help='Starts the service without waiting for drive to be connected. '
        'Will fail if drive is unmounted during the attempt.'
    )

    # TODO implement negation of this (or delete if fstab setup working really
    # well) any reason we wouldn't want to just throw the drive into fstab?
    '''
    parser.add_argument('--allow-unclean-mountdirs', action='store_true',
        help='If this is not passed, empty mount dirs sharing prefix '
        'with mount_point will raise an error.'
    )
    '''
    parser.add_argument('--strip-trailing-nums', action='store_true',
        help='Does not include trailing number on mount point in fstab line. '
        'This is a hack to get mount point before multiple copies of it are '
        'created.'
    )

    # Mostly for testing without having to actually [un/re]plug drive.
    # Note: need to add an extra backslash to any lone backslashes, to
    # prevent bash / other shell from stripping it out.
    parser.add_argument('--drive-info', nargs=2, help='Use this '
        'drive info, rather than discovering by connecting the drive. '
        'systemctl service unit and mount point, space separated.'
    )

    # The .sh wrapper should pass these two (user & python) in.
    parser.add_argument('--user', action='store',
        help='Non-root user to be used to run the triggered script. '
        'DO NOT PASS (used internally by wrapper .sh script).'
    )
    parser.add_argument('--python', action='store',
        help='Full path to Python executable to use to start triggered script. '
        'DO NOT PASS (used internally by wrapper .sh script).'
    )
    args = parser.parse_args()

    last_installed_pickle = '.last_installed_service.p'

    # These are global variables used in the functions above.

    if not args.remove_last_installed:
        # If this is gonna be used to name service too, will also need on
        # uninstall.
        if args.drive_info is None:
            drive_systemctl_unit, mount_point = get_drive_info()
        else:
            drive_systemctl_unit, mount_point = args.drive_info

        uuid, filesystem_type = get_drive_fstab_info(mount_point)

        if args.strip_trailing_nums:
            # Important that this happens after get_drive_fstab_info, because
            # that needs to inspect the real (mounted) mount point, not the
            # clean one that we are only now going to create in fstab and use
            # for the service.
            if mount_point[-1].isdigit():
                print('stripping trailing number from mount point')
                mount_point = mount_point[:-1]
                assert not mount_point[-1].isdigit()

            # Only expecting one period in this.
            prefix, suffix = drive_systemctl_unit.split('.')
            if prefix[-1].isdigit():
                print('stripping trailing number from systemctl unit')
                assert not prefix[-2].isdigit()
                drive_systemctl_unit = prefix[:-1] + '.' + suffix

        example_config = 'example_linux_config.yaml'
        service_config_file = \
            util.service_unit_config_file(drive_systemctl_unit)

        service_templ_path = 'usb_copy_on_conn.service.templ'
        without_suffix = util.service_unit_without_suffix(drive_systemctl_unit)
        service_name = without_suffix + '-' + splitext(service_templ_path)[0]
        # It seems to be convention to use '-' rather than '_' in service names.
        service_name = service_name.replace('_', '-')
        #service_path = join('/etc/systemd/system', service_name)

        # This says Ubuntu 16.04 still uses upstart for user sessions
        # (in contrast to systemd), so maybe trying to run a user service
        # this way is a fools errand?
        # Can't seem to find a workaround so tkinter can display stuff in
        # non-user session though...
        #service_dir = f'/home/{args.user}/.config/systemd/user'

        service_path = join('/etc/systemd/system', service_name)

        print('\nAdd these arguments to refer to this drive without discovery:')
        bs_escaped_systemctl_unit = drive_systemctl_unit.replace("\\", "\\\\")
        space_escaped_mount_point = '\ '.join(mount_point.split())
        print(f'--drive-info {bs_escaped_systemctl_unit} '
            f'{space_escaped_mount_point}'
        )

    else:
        with open(last_installed_pickle, 'rb') as f:
            data = pickle.load(f)

        # These should be the only globals we need to uninstall the service.
        service_name = data['service_name']
        service_path = data['service_path']
        service_config_file = data['service_config_file']
        uuid = data['uuid']

    with open('/etc/fstab', 'r') as f:
        fstab_contents = f.read()

    # End global variables.

    # For manual inspection of service w/ existing CLI tools.
    print('\nService name:', service_name.replace('\\', '\\\\'))
    print('')

    if args.install:
        install(python_path=args.python)

        data = {
            'service_name': service_name,
            'service_path': service_path,
            'service_config_file': service_config_file,
            'uuid': uuid
        }
        with open(last_installed_pickle, 'wb') as f:
            pickle.dump(data, f)

    elif args.remove or args.remove_last_installed:
        remove()

        if args.remove_last_installed:
            os.remove(last_installed_pickle)

